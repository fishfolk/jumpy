<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fish Fight Documentation</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="gameplay.html"><strong aria-hidden="true">1.</strong> Gameplay</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="controls.html"><strong aria-hidden="true">1.1.</strong> Controls</a></li><li class="chapter-item expanded "><a href="items.html"><strong aria-hidden="true">1.2.</strong> Items</a></li><li class="chapter-item expanded "><a href="multiplayer.html"><strong aria-hidden="true">1.3.</strong> Multiplayer</a></li></ol></li><li class="chapter-item expanded "><a href="mechanics.html"><strong aria-hidden="true">2.</strong> Mechanics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="physics.html"><strong aria-hidden="true">2.1.</strong> Physics</a></li><li class="chapter-item expanded "><a href="environmental_weapons.html"><strong aria-hidden="true">2.2.</strong> Environmental Weapons</a></li><li class="chapter-item expanded "><a href="netcode.html"><strong aria-hidden="true">2.3.</strong> Netcode</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">3.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="simple_gun_weapon.html"><strong aria-hidden="true">3.1.</strong> Simple Gun Weapon</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Fish Fight Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/fishfight/FishFight" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#gameplay" id="gameplay">Gameplay</a></h1>
<h1><a class="header" href="#controls" id="controls">Controls</a></h1>
<h2><a class="header" href="#keyboard-right" id="keyboard-right">Keyboard Right</a></h2>
<table><thead><tr><th align="center">Key</th><th align="center"></th><th align="center">Action</th></tr></thead><tbody>
<tr><td align="center">Up</td><td align="center"><img src="assets/up_key.gif" alt="up_key" /></td><td align="center">Jump</td></tr>
<tr><td align="center">Down</td><td align="center"><img src="assets/down_key.gif" alt="down_key" /></td><td align="center">Crouch</td></tr>
<tr><td align="center">Left</td><td align="center"><img src="assets/left_key.gif" alt="left_key" /></td><td align="center">Move left</td></tr>
<tr><td align="center">Right</td><td align="center"><img src="assets/right_key.gif" alt="right_key" /></td><td align="center">Move right</td></tr>
<tr><td align="center">K</td><td align="center"><img src="assets/k_key.gif" alt="k_key" /></td><td align="center">Pickup/Drop</td></tr>
<tr><td align="center">L</td><td align="center"><img src="assets/l_key.gif" alt="l_key" /></td><td align="center">Attack</td></tr>
<tr><td align="center">0</td><td align="center"><img src="assets/0_key.gif" alt="0_key" /></td><td align="center">Toggle AI</td></tr>
</tbody></table>
<h2><a class="header" href="#keyboard-left" id="keyboard-left">Keyboard Left</a></h2>
<table><thead><tr><th align="center">Key</th><th align="center"></th><th align="center">Action</th></tr></thead><tbody>
<tr><td align="center">W</td><td align="center"><img src="assets/w_key.gif" alt="w_key" /></td><td align="center">Jump</td></tr>
<tr><td align="center">S</td><td align="center"><img src="assets/s_key.gif" alt="s_key" /></td><td align="center">Crouch</td></tr>
<tr><td align="center">A</td><td align="center"><img src="assets/a_key.gif" alt="a_key" /></td><td align="center">Move left</td></tr>
<tr><td align="center">D</td><td align="center"><img src="assets/d_key.gif" alt="d_key" /></td><td align="center">Move right</td></tr>
<tr><td align="center">C</td><td align="center"><img src="assets/c_key.gif" alt="c_key" /></td><td align="center">Pickup/Drop</td></tr>
<tr><td align="center">V</td><td align="center"><img src="assets/v_key.gif" alt="v_key" /></td><td align="center">Attack</td></tr>
<tr><td align="center">1</td><td align="center"><img src="assets/1_key.gif" alt="1_key" /></td><td align="center">Toggle AI</td></tr>
</tbody></table>
<h2><a class="header" href="#gamepad" id="gamepad">Gamepad</a></h2>
<table><thead><tr><th align="center">Input</th><th align="center"></th><th align="center">Action</th></tr></thead><tbody>
<tr><td align="center">A Button</td><td align="center"><img src="assets/a_button.gif" alt="a_button" /></td><td align="center">Jump</td></tr>
<tr><td align="center">Y Button</td><td align="center"><img src="assets/y_button.gif" alt="y_button" /></td><td align="center">Crouch</td></tr>
<tr><td align="center">Left Thumbstick</td><td align="center"><img src="assets/left_thumb.gif" alt="left_thumb" /></td><td align="center">Move left</td></tr>
<tr><td align="center">Right Thumbstick</td><td align="center"><img src="assets/right_thumb.gif" alt="right_thumb" /></td><td align="center">Move right</td></tr>
<tr><td align="center">X Button</td><td align="center"><img src="assets/x_button.gif" alt="x_button" /></td><td align="center">Pickup/Drop</td></tr>
<tr><td align="center">B Button</td><td align="center"><img src="assets/b_button.gif" alt="b_button" /></td><td align="center">Attack</td></tr>
</tbody></table>
<h1><a class="header" href="#items" id="items">Items</a></h1>
<p>Items are placed in levels and can be interacted with by players.</p>
<table><thead><tr><th align="center">Name</th><th align="center"></th><th align="center">Description</th></tr></thead><tbody>
<tr><td align="center">Musket</td><td align="center"><img src="assets/musket.png" alt="musket" /></td><td align="center">Fires up to three bullets, normal recoil, normal bullet speed.</td></tr>
<tr><td align="center">Sniper</td><td align="center"><img src="assets/sniper.png" alt="sniper" /></td><td align="center">Fires up to two bullets, high recoil, high bullet speed.</td></tr>
<tr><td align="center">Machine Gun</td><td align="center"><img src="assets/machine_gun.png" alt="machine_gun" /></td><td align="center">Fires many bullets, low recoil, normal bullet speed.</td></tr>
<tr><td align="center">Cannon</td><td align="center"><img src="assets/cannon.png" alt="cannon" /></td><td align="center">Fires up to three bombs, normal recoil.</td></tr>
<tr><td align="center">Turtle Shell</td><td align="center"><img src="assets/turtle_shell.png" alt="turtle_shell" /></td><td align="center">Blocks two attacks from behind, then breaks.</td></tr>
<tr><td align="center">Shoes</td><td align="center"><img src="assets/shoes.png" alt="shoes" /></td><td align="center">Allows user to attack players by jumping on their heads.</td></tr>
<tr><td align="center">Galleon</td><td align="center"><img src="assets/galleon.png" alt="galleon" /></td><td align="center">Summons a galleon that travels across the arena. Kills anything in its path.</td></tr>
<tr><td align="center">Volcano</td><td align="center"><img src="assets/volcano.png" alt="volcano" /></td><td align="center">Summons a volcano that randomly shoots bombs into the arena.</td></tr>
<tr><td align="center">Shark Rain</td><td align="center"><img src="assets/shark_rain.png" alt="shark_rain" /></td><td align="center">Summons sharks that rain down from above. Kills anything in their path.</td></tr>
<tr><td align="center">Grenades</td><td align="center"><img src="assets/grenades.png" alt="grenades" /></td><td align="center">Throws up to three bombs that explode after short duration or on impact.</td></tr>
<tr><td align="center">Mines</td><td align="center"><img src="assets/mines.png" alt="mines" /></td><td align="center">Place up to three mines that explode on contact.</td></tr>
<tr><td align="center">Jellyfish</td><td align="center"><img src="assets/jellyfish.png" alt="jellyfish" /></td><td align="center">Fires a jellyfish that is controlled by the player and explodes impact.</td></tr>
<tr><td align="center">Sproinger</td><td align="center"><img src="assets/sproinger.png" alt="sproinger" /></td><td align="center">Bounces player when jumped on.</td></tr>
</tbody></table>
<h1><a class="header" href="#multiplayer" id="multiplayer">Multiplayer</a></h1>
<p>Connection process in the FishFight is extremely low-level right now.<br />
We do not have matchmaking server and we want to collect data and network setups and possible problems before doing the process fully automatic.</p>
<p><img src="https://user-images.githubusercontent.com/910977/133952684-19e7f10a-ed80-49e6-8a31-205f28a78c39.png" alt="image" /></p>
<p>The only supported game mode right now: 1v1.</p>
<h2><a class="header" href="#connection-types" id="connection-types">Connection Types</a></h2>
<h3><a class="header" href="#lan" id="lan">LAN</a></h3>
<p>When both computers are connected to the same router: are on the same wifi, home network etc.</p>
<p>Send your local IP from &quot;Self addr&quot; field to your opponent, click &quot;Probe connection&quot; and if connection can be established - click &quot;Connect&quot;.</p>
<h3><a class="header" href="#stun" id="stun">STUN</a></h3>
<p>When each player is under a NAT. Usually when its two players over internet with different network providers.
This option may work, but may not, it depends on the type of nat, router configs etc.</p>
<p>Idea is exactly the same as with LAN: copy-paste your own &quot;Self addr&quot; over discord, probe connection, if it works - click &quot;Connect&quot;</p>
<h3><a class="header" href="#relay" id="relay">Relay</a></h3>
<p>When both players are on remote computers over internet, but STUN connection did not worked and router reconfiguration is not an option - there is a relay server available.</p>
<p>Relay server will introduce additional LAG - each packet will be forwarded through a server.</p>
<p>Connection idea is still the same, but instead of IP &quot;Self addr&quot; will be an ID on the relay server. Copy-paste it over internet, set &quot;Opponent addr&quot;, push &quot;Connect&quot;</p>
<h2><a class="header" href="#router-configuration" id="router-configuration">Router Configuration</a></h2>
<p>When STUN server failed, but Relay is too slow - there is a way to improve gameplay experience. Go to router settings and forward ports 3400, 3401, 3402, 3403 to computer with the FishFight.</p>
<p>It still may depend on the internet provider, maybe the router itself is behind some global, provider NAT or something.</p>
<p>TODO: Make a better &quot;Router configuration&quot; section here.</p>
<h1><a class="header" href="#mechanics" id="mechanics">Mechanics</a></h1>
<h1><a class="header" href="#physics" id="physics">Physics</a></h1>
<p>As you might already know, Fish Fight is a homage to the excellent Duck Game and thus we have chosen to replicate the rather simple and straight forward linear physics found in that game. It follows standard platformer physics, with force being translated to two-dimensional velocity, acting against gravity and drag, every physics update (<code>fixed_update</code>).</p>
<p><a href="https://maddythorson.medium.com/celeste-and-towerfall-physics-d24bd2ae0fc5">The same physics system is used in Towerfall and Celeste.</a></p>
<p>To learn more about basic game physics, as they are implemented in Fish Fight, you can explore the following sources:</p>
<p><code>[Ask us about missing links!]</code></p>
<h2><a class="header" href="#fish-fights-physics-implementation" id="fish-fights-physics-implementation">Fish Fight's physics implementation</a></h2>
<p>As for the specifics of Fish Fight, I will elaborate in the following paragraphs. Please note, however, that the game is currently in a very early prototype stage, so the implementation is neither perfect nor, in any way, optimized, at this stage.</p>
<h3><a class="header" href="#scene-nodes" id="scene-nodes">Scene nodes</a></h3>
<p>The game uses the <a href="https://github.com/not-fl3/macroquad">Macroquad library</a>, by <a href="https://github.com/not-fl3">Fedor</a>, who is also part of the core team of Fish Fight. This means that our scenes are composed of scene nodes, made by implementing the <code>Node</code> type. The most relevant method, when discussing physics, is the <code>fixed_update</code> method, which is called for every node, every physics frame. This means that, in order to explore the existing physics of any existing in-game object, you should browse to the corresponding node source file, in <a href="https://github.com/fishfight/fish2/tree/master/src/nodes"><code>src/nodes</code></a>, and look for the <code>impl Node for T</code> section and the encapsulated <code>fixed_update</code> implementation.</p>
<p>This method takes a <code>RefMut&lt;T&gt;</code> as an argument (can be both mutable and immutable), where <code>T</code> is the type of the node that it is being implemented for. From here, you can do many things; like manipulating the node, itself, through the <code>RefMut&lt;T&gt;</code> parameter, as well as access other nodes by fetching them from the scene, either by type, or by specific traits, made by calling <code>node.provides([...])</code> in a nodes <code>ready</code> implementation. For examples of this, you can check the code of most nodes for the code providing the <code>Sproingable</code> trait, for example.</p>
<p>Examples of code for accessing other nodes:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// This is from the ArmedGrenade node, showing how we iterate over players, checking for
// collision and killing the player if the explosion &quot;collides&quot; with the player
for mut player in scene::find_nodes_by_type::&lt;crate::nodes::Player&gt;() {
    let intersect =
        grenade_rect.intersect(Rect::new(
            player.body.pos.x,
            player.body.pos.y,
            PLAYER_HITBOX_WIDTH,
            PLAYER_HITBOX_HEIGHT,
        ));
    if !intersect.is_none() {
        let direction = node.body.pos.x &gt; (player.body.pos.x + 10.);
        scene::find_node_by_type::&lt;crate::nodes::Camera&gt;()
            .unwrap()
            .shake();
        player.kill(direction);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// This is from the Sproinger node, iterating through nodes providing the Sproingable trait
// and checking for collision, before performing a &quot;sproing&quot; on them, if they overlap
for (_actor, mut body_lens, size) in scene::find_nodes_with::&lt;Sproingable&gt;() {
    if body_lens.get().is_some() {
        let body = body_lens.get().unwrap();
        if body.speed.length() &gt; Self::STOPPED_THRESHOLD {
            let intersect = sproinger_rect
                .intersect(Rect::new(body.pos.x, body.pos.y, size.x, size.y));
            if !intersect.is_none() {
                let resources = storage::get_mut::&lt;Resources&gt;();
                play_sound_once(resources.jump_sound);

                body.speed.y = -Self::FORCE;
                node.has_sproinged = true;
                // self.sprite.set_animation(1);
                // self.sprite.playing = true;
                Sproinger::animate(node.handle());
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#collision" id="collision">Collision</a></h3>
<p>Collision between nodes is done by creating collider <code>Rect</code> or <code>Circle</code> objects and calling their <code>intersect</code> (<code>Rect</code> only) or <code>overlaps</code> methods. The former will return an<code>Option&lt;Rect&gt;</code>, where the contained <code>Rect</code> represents the intersection between the two colliding <code>Rect</code> objects, or <code>None</code>, if there was no intersection. The latter will return a <code>bool</code> that is <code>true</code> if there was any overlap between the two objects. To check for collisions with the map, you have several methods in the <code>scene</code> module that lets you check for collisions on the various map layers. For examples of map collisions, once again, the <a href="https://github.com/fishfight/fish2/tree/master/src/nodes/player.rs"><code>Player</code></a> implementation is a good place to start. Furthermore, <code>PhysicsBody</code> members may hold a collider that Macroquads physics engine will collide against <code>Solid</code> objects in the scene (ground tiles, for the most part). These colliders will have to be added to the collision world, as actors. See the constructor of the <a href="https://github.com/fishfight/fish2/tree/master/src/nodes/player.rs"><code>player node</code></a> for an example of how this is done.</p>
<p>NOTE: To get the hitbox of a Player node, use <code>Player::get_hitbox()</code>, so that you get the correct size if the player node, for example, is in a crouched state.</p>
<h3><a class="header" href="#force" id="force">Force</a></h3>
<p>When it comes to enacting force on nodes, this is done by setting a speed on a node. Most nodes will have a body, but not all, as the primary use for a body is to hold a collider. For simpler nodes, we might just put a position vector and a speed vector directly on the node, in stead. This can be checked in the specific nodes implementation. As mentioned, we set the velocity directly, in stead of accumulating force over several frames, as this leads to much more predictable and precise game physics (the age old Mario, using acceleration, vs Megaman, using binary force, dichotomy).</p>
<p>This means that, in order to implement an explosion, for example, you would decide on a force, find the node(s) that the explosion will act upon and apply this force by setting the speed of the node, or the nodes body, depending on its implementation, to the value of the force in the appropriate direction. See below for a simplified example of something exerting a force, on the x-axis, on a player, if an arbitrary hit check condition is fulfilled:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl T {
    pub const FORCE: f32 = 900.0;
}

impl Node for T {
    for mut player in scene::find_nodes_by_type::&lt;crate::nodes::Player&gt;() {
        [hit detection]
        if is_hit {
            let direction_is_right = node.body.pos.x &gt; (player.body.pos.x + 10.);
            player.body.speed.x = if direction_is_right {
                FORCE
            } else {
                -FORCE // negative force
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The same methods would be used for movement, for example, but instead of checking for a collision, you would check for input. For examples of this, check out the <a href="https://github.com/fishfight/fish2/tree/master/src/nodes/player.rs"><code>player node implementation</code></a>.</p>
<h1><a class="header" href="#environmental-weapons" id="environmental-weapons">Environmental weapons</a></h1>
<ul>
<li><a href="environmental_weapons.html#environmental-weapons">Environmental weapons</a>
<ul>
<li><a href="environmental_weapons.html#document-notes">Document notes</a></li>
<li><a href="environmental_weapons.html#mechanics-and-examples">Mechanics and examples</a></li>
<li><a href="environmental_weapons.html#code-design">Code design</a></li>
</ul>
</li>
</ul>
<p>Environmental weapons are weapons that don't follow the structure of weapon and projectile, rather, they spawn one or more entities intended to harm enemy.</p>
<h2><a class="header" href="#document-notes" id="document-notes">Document notes</a></h2>
<p>This document doesn't explain all the concepts, since some are already explained in <a href="physics.html">Physics</a>.</p>
<p><code>EW</code> is used as abbreviation for <code>E</code>nvironmental <code>W</code>eapon.</p>
<h2><a class="header" href="#mechanics-and-examples" id="mechanics-and-examples">Mechanics and examples</a></h2>
<p>For each pickup, it's possible to spawn the weapon only once; after usage, most will disappear entirely from the level.</p>
<p>Currently, there are a few EWs:</p>
<ul>
<li>Curse: a skull that chases the closest enemy, in a sinusoidal motion, for a limited amount of time;</li>
<li>Galleon: a large vessel that crosses the screen horizontally;</li>
<li>Shark rain: a group of sharks falling vertically from the top, at random horizontal positions.</li>
</ul>
<p>EWs may, or may not, self-pwn the owner.</p>
<h2><a class="header" href="#code-design" id="code-design">Code design</a></h2>
<p>EWs are typically designed in two main types: the item, which is what the player can pick up/hold/throw, and the weapon itself, which is the set of entities that are summoned and harm the enemies.</p>
<p>The general design is very similar to all the other weapons, with a few distinctions.</p>
<p>The <code>shoot()</code> routine, itself common to the other weapons, is a good starting point:</p>
<pre><code class="language-rs">pub fn shoot(galleon: Handle&lt;Galleon&gt;, player: Handle&lt;Player&gt;) -&gt; Coroutine {
    let coroutine = async move {
        /* ... */

        if galleon.used {
            player.state_machine.set_state(Player::ST_NORMAL);
            return;
        }

        galleon.used = true;

        FlyingGalleon::spawn(player.id);

        player.weapon = None;
        
        /* ... */

        galleon.delete();

        player.state_machine.set_state(Player::ST_NORMAL);
    };

    start_coroutine(coroutine)
}
</code></pre>
<p>A very important concept is that we must avoid race conditions on multiple shots. Since shooting is asynchronous, on the first shot, we need to set a flag (in this case, <code>used</code>) that makes other concurrent executions return.</p>
<p>Most EWs are usable only once per level; this is implemented by removing the weapon from the player (see above), and deleting the item from the node graph.</p>
<p>Since most of the EWs don't kill the owner, we store the Player id in the spawned type, and skip it on collision test:</p>
<pre><code class="language-rs">pub struct FlyingGalleon {
    /* ... */
    owner_id: u8,
}

impl scene::Node for FlyingGalleon {
    fn fixed_update(mut flying_galleon: RefMut&lt;Self&gt;) {
        /* ... */

        for mut player in scene::find_nodes_by_type::&lt;crate::nodes::Player&gt;() {
            if player.dead {
                continue;
            }

            if flying_galleon.owner_id != player.id {
                /* Collision test here */
</code></pre>
<p>We also check if a player is dead, before performing the the collision check: since the EWs are generally large, performing the test multiple times is not correct; for example, it has the immediate effect of causing multiple death effects.</p>
<p>EWs typically need to know the boundaries of the map; see the <code>FlyingGalleon#start_position_data()</code> routine:</p>
<pre><code class="language-rs">fn start_position_data() -&gt; (Vec2, bool) {
    let resources = storage::get::&lt;Resources&gt;();

    // We query the map size from the raw tiled map data:

    let map_width =
        resources.tiled_map.raw_tiled_map.tilewidth * resources.tiled_map.raw_tiled_map.width;
    let map_height =
        resources.tiled_map.raw_tiled_map.tileheight * resources.tiled_map.raw_tiled_map.height;

    // Note also how we generate a random boolean via MacroQuad `rand` APIs:

    let (start_x, direction) = if gen_range(0., 1.) &lt; 0.5 {
        (0. - FLYING_GALLEON_WIDTH, true)
    } else {
        ((map_width - 1) as f32, false)
    };

    let start_y = gen_range(0., map_height as f32 - FLYING_GALLEON_HEIGHT);

    (vec2(start_x, start_y), direction)
}
</code></pre>
<h1><a class="header" href="#netcode" id="netcode">Netcode</a></h1>
<p>The netcode in <a href="https://github.com/fishfight/FishFight">Fish Fight</a> is something called delay-based netcode by many players, but is more  specifically deterministic lockstep. A peer-to-peer architecture that is completely deterministic.</p>
<p>This video was the main inspiration for our netcode architecture:</p>
<iframe src="https://www.youtube.com/embed/7jb0FOcImdg" allowfullscreen="" width="500" height="281" frameborder="0"></iframe>
<p>What is described from 6:09 to 7:15 is the current state of our  netcode. The video proceeds to explain the limitations of this approach  and how they iterated from there to what can more accurately be called <a href="https://en.wikipedia.org/wiki/GGPO">GGPO</a>. That is where we are headed as well, beginning with a minimal  foundation that we have a full grasp and agency over. From the  intentionally naive “Player Unhappy” model we will gradually work our  way towards “Player Very Happy”.</p>
<h2><a class="header" href="#terms-and-concepts" id="terms-and-concepts">Terms and Concepts</a></h2>
<p>Before we go any further, let’s explain some terms and concepts.</p>
<p>First off, what makes online multiplayer games difficult to make?  There are two main issues: (1) The latency (travel time) for information over the internet, and (2) when circumventing that, ensuring that  nobody can cheat while also fairly integrating everyone’s input. What’s  important isn’t that the solution is ”correct”, but that it feels great  to your players. Game networking consists largely of clever tricks and  smoke and mirrors, all to disguise the inherent limits of space-time.</p>
<p>A peer/client is someone who joins an online game session. (We will  use these terms interchangeably, but there might be reasons to  differentiate the two). For example, when you play Minecraft, you join  servers as a client. Most games these days use a server-client  architecture, where clients will join a server that handles everything  in the online game session, and streams necessary data to the clients.</p>
<p>However, this isn’t the only way of handling things. Indeed, before  the server-client architecture became commonplace, there was the  peer-to-peer (P2P) architecture. Instead of relying on an authoritative  server to tell the clients what’s happening, the peers instead tell EACH OTHER what is happening. This means that any one peer has to send out  data to every single other peer, and as such the required bandwidth  scales linearly as more players join. For this reason most games just  use the server-client system for anything more than 6-8 players.  However, for a game like Fish Fight which will only have 2-4 players in  any one given match, a peer-to-peer system will make more sense.</p>
<p>This has several benefits. First and foremost, there’s no need to pay for hosting. While for a small project like Fish Fight, with a  relatively simple simulation, that cost would likely be low. But there’s a plethora of problems that must be addressed: that cost isn’t zero and still has to be paid somehow, and if the game gets immensely popular  the price will quickly skyrocket. And then you must also write a load  distribution system, and DDOS protection, the list goes on. A  peer-to-peer architecture offloads all the costs to the players, who are in any case already running the simulation. This also means that you  don’t need to maintain two separate client and server codebases, that  must exactly line up in behaviour. Peer-to-peer might even offer lower  latency, since the packets don’t have to go back and forth through a  server.</p>
<p>This is because hosting servers is EXPENSIVE. For example, hosting a  Minecraft server on Minecraft Realms is $8 dollars per month. That’s not much, but it's only one session. If we assume that this will “only”  have a max player count of 40 people per day, that means we have to host 10 servers. That means $80 dollars per month. This doesn’t even take  into account all of the other things we might have to worry about when  developing a server-client architecture, like having to maintain two  different codebases at the same time.</p>
<p>As such, making a peer-to-peer game makes sense at this scale.  However, any one who wants to make an online multiplayer game MUST  understand that every multiplayer solution is specialized to your  use-case. The server-client architecture has many other benefits, mainly scalability. But also, in Fish Fight there is no persistent state or  complex systems that must always be online. The ”servers” in P2P go  offline as soon as a player quits.</p>
<p>The Authority is whoever decides what is true, and can overwrite  anyone else’s state. The authority isn’t necessarily one party, but  rather authority is held over singular objects or values. For example, a player might hold authority over a ball they are kicking, so they don’t have to ask the server for confirmation before interacting resulting in a snappier experience. This isn’t exactly applicable in a lockstep P2P  architecture, but is foundational for client-servers so you’ll likely  see the term if you ever read anything about networking. In those cases  the server is almost always the authority, so the players can’t cheat.</p>
<p>Listen Servers are a network architecture/topology not to be confused with peer-to-peer. It is simply a client-server architecture where one  of the clients hosts the server. This combines the cost benefits of a  P2P topology while also allowing for better lag compensation methods. It still requires the same bandwidth as P2P, but only for the client who  is running the server so the game is no longer capped by the slowest  connection. Fish Fight might eventually move to this topology or move to a P2P model.</p>
<p>Ping/Latency/Round Trip Time all relate to the time it takes for a  message to travel over a network. Latency is the time it takes to travel from the sender to the recipient, while Round Trip Time (RTT) and Ping  refers to the time it takes both back and forth. RTT however is not  necessarily twice the latency, although often very close. On the  network, different conditions and even routes means that times will  vary.</p>
<p>Jitter is related to latency, and is the amount by which it varies. A bad connection does not only have long latency, but the time it takes  for packets to arrive will also vary greatly. This is a major hindrance  when you want data to arrive in a smooth and regular manner, such as  frames in a video, sound in a voice chat or input for a player. This is  managed by adding a Buffer, which stores values for a short while and  then dispenses them like an even flow. The tradeoff is that the fastest  packets are slowed down to be in time with the slowest packets, leading  to an overall slowdown.</p>
<p>Then there’s Packet Loss, where a packet gets completely lost at some crossroad of the internet. Bad connections also means that not all  packets will arrive. This is countered by adding Redundancy. Common ways to compensate is to send packets multiple times, so at least one is  likely to arrive, or send a confirmation once a packet is received. If  the confirmation is not received, resend the packet until you get a  response.</p>
<p>For some slightly more low-level things that you can do without:</p>
<p>TCP/UDP relates to packet loss. UDP is a transport protocol on the IP stack that “simply” sends messages, fire-and-forget, with no regard to  whether it arrives. TCP on the other hand has more overhead but  guarantees that your messages arrive. FishFight uses UDP for speed, and  implements a custom redundancy layer on top of that for extra  performance. TCP is often overkill, and a custom built solution almost  always works better since it can exploit the exact workings of your  game. Overhead is the extra data that is sent every packet, and adds to  the required bandwidth. By sending more data per packet, the overhead  will make up a smaller part of the data sent.</p>
<h2><a class="header" href="#delayed-lockstep" id="delayed-lockstep">Delayed Lockstep</a></h2>
<p>Anyways, we explained the peer-to-peer part, but you’re probably  wondering what is deterministic lockstep. Gaffer on Games already wrote  about this in <a href="https://gafferongames.com/post/deterministic_lockstep/">an article you can read here</a>, but in summary.</p>
<p>At its very basics, lockstep works by collecting input from every  player and then simulating one frame once all input is gathered. In  other words, the only thing that gets transmitted between players is  their input. Input often can be packed into a single byte, and therefore very little bandwidth is required. When the input then arrives, the  simulation is advanced one step. Since everyone waits for input from  each other, everyone steps in sync.</p>
<p>But however small the packets are, the latency will remain largely  the same. To wait for every player to send their input each time would  mean that the game can not update faster than (in the best case) 1/RTT/2 Hz (confirmation can be sent later). If you want your game loop to run  at 60Hz, you can’t have an RTT over 30 ms which is difficult to achieve  outside of wired and geographically small networks.</p>
<p>Enter: Delayed Lockstep. The ”delay” part is an input buffer that  stores inputs for a short while before executing them. Now every input  packet also contains a frame timestamp so that all remote input can be  matched up with the local input and executed at the same frame. As input rolls in it is stored in the matching slot in a buffer, and by the time a frame should be simulated the corresponding buffer slot should be  filled with input from all players. The latest input is then popped off  the buffer, which shifts one frame forward, and the game progresses one  step. By maintaining this buffer (barring major interruptions) the game  always has input at hand, and can as soon and as quickly as it wants.  But as you might guess, there’s a tradeoff, and that is of course the  added delay. The remote players already have some delay so it doesn’t  matter too much, but the local input must be slowed down to match the  slowest player, leading to slower response to keyboard input. To  minimise this delay, the buffer should be as short as possible. To give  everyone’s input time to arrive the buffer must be as long as the  slowest players ping + their jitter. To improve the experience, your  networking should continually measure how long it is between the last  player’s input arriving and the buffer running out, and then adjusting  the buffer to be as short as possible. A too long buffer means  unnecessary input delay, but if the buffer is too short and runs out the game must freeze until input arrives. It’s a fine line to walk, but  it’s usually better to lean towards too long than having interruptions.</p>
<p>However, there’s one big, or rather HUGE, issue: Determinism. Since  all that is sent between clients is their inputs, one requirement must  be met. Given the same world state and inputs, every time, on every  computer, OS, architecture, instruction set, etc. etc. the game must be  able to generate the exact same next frame. The tiniest deviation  accumulates and quickly makes the game unplayable. The main source of  nondeterminism is floating point arithmetic. Performing operations with  floating point numbers famously produces varying results, which depends  on many factors. Random number generators must also be kept in sync.</p>
<p>We want to reduce the amount of data being sent online by each peer,  AND we don’t want to have people hack the game. The way to do this then, is to have players only send their inputs to each other, so that you  can’t have people change their position all willy nilly <a href="https://www.youtube.com/watch?v=yMVkh4BJe7k">like this</a>.</p>
<p>However, we want to make sure that when inputs are sent to each  player, the game itself is fully deterministic: the same thing must  happen with the same inputs every time to prevent clients from desyncing with each other. There’s a lot of ways to handle this that we not going to get into, but I’m sure could make for a very interesting separate  article.</p>
<p>For now, we are going to assume that the game itself is fully deterministic and just take a look at the code itself in <a href="https://github.com/fishfight/FishFight/blob/main/src/nodes/network.rs">src/nodes/network.rs</a>.</p>
<p>We are first going to take a look at the data being sent online, the  packets. In this case, the packets in network.rs are called messages,  which is what they are so it makes sense.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(DeBin, SerBin)]
enum Message {
    Input {
        // position in the buffer
        pos: u8,
        // current simulation frame
        frame: u64,
        input: Input,
    },
    Ack {
        // last simulated frame
        frame: u64,
        /// bitmask for last 8 frames
        /// one bit - one received input in a frames_buffer
        ack: u8,
    },
}
<span class="boring">}
</span></code></pre></pre>
<p>Each message has two different parts to it. It has an Input struct,  which contains the position in the input buffer, the frame that the game is currently on, and the actual input. It also has an Ack struct (which is sent to assure the other clients they received their input) that  contains the frame the game is on. The Ack struct also has a bitflag  that tells what inputs they got from what clients.</p>
<p>Now, the person reading this might wonder: why is there an input  buffer here? Well, we forgot to mention one thing. See, in the real  world, deterministic lockstep doesn’t actually work. Well, it doesn’t work the way you might think at first.</p>
<p>Every packet being sent online is always going to have a little bit  of delay to it (latency) since there is going to be some distance that  is covered by the packet as it travels. Even at the speed of light, it  still takes a nanosecond for a packet to get across from one side of the room to the other.</p>
<p>As such, if you were to have a naive interpretation of deterministic  lockstep without accounting for latency, it would just freeze every  single frame as it waits for inputs to appear.</p>
<p>This image taken from <a href="https://ki.infil.net/w02-netcode.html">Infil’s article about the netcode in Killer Instinct</a> (with permission!) should show what that looks like.</p>
<iframe src='https://gfycat.com/ifr/FaithfulImmaculateBug' frameborder='0' scrolling='no' allowfullscreen width='640' height='405'></iframe>
<p>(Note that this isn’t actually delay-based netcode either, but that’s a discussion for another time)</p>
<p>What instead is done is adding in an artificial delay to the program  itself, and having a buffer of input of a certain amount of frames. This allows the inputs time to arrive.</p>
<iframe src='https://gfycat.com/ifr/ActiveFormalAtlanticsharpnosepuffer' frameborder='0' scrolling='no' allowfullscreen width='640' height='405'></iframe>
<p>When the inputs come to the other players, it gets added into the  input buffer which also lasts a certain amount of frames. This means  that most moves and stuff feel noticeably slower with added delay.</p>
<iframe src='https://gfycat.com/ifr/AffectionateDescriptiveAiredaleterrier' frameborder='0' scrolling='no' allowfullscreen width='640' height='405'></iframe>
<hr />
<p>This concludes part 1 of our &quot;Netcode Explained&quot; series. In part 2 we will do a code walk-through and piecemeal analysis.</p>
<p><em>Written by Srayan “ValorZard” Jana and grufkok, with editing by Erlend</em></p>
<h1><a class="header" href="#contributing" id="contributing">Contributing</a></h1>
<p>Fish Fight aims to be a highly contributor-friendly game. More instructions are coming soon. For now we recommend all newcomers start with our <a href="https://github.com/fishfight/FishFight/issues/124">Development Tracks</a>.</p>
<h1><a class="header" href="#simple-gun-weapon" id="simple-gun-weapon">Simple Gun Weapon</a></h1>
<p>This section will walk through the process of adding a new gun weapon to Fish Fight, using a sniper weapon as an example. The weapon added in this section will be an instance of the <code>Gun</code> struct.</p>
<h2><a class="header" href="#planning" id="planning">Planning</a></h2>
<p>Before jumping into the games code, it is a good idea to do some planning about what you want your new weapon to do. I determined that my sniper weapon should have the following properties:</p>
<ul>
<li>High bullet speed</li>
<li>Large recoil</li>
<li>2 bullets</li>
</ul>
<h2><a class="header" href="#programming" id="programming">Programming</a></h2>
<p>Open your cloned &quot;FishFight&quot; directory using your code editor of choice.</p>
<h3><a class="header" href="#item-file" id="item-file">Item File</a></h3>
<p>Open <code>src/items.rs</code> and add a new module called <code>your_weapon</code> at the top of the file. Below is the code for adding the sniper module:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod sniper;
<span class="boring">}
</span></code></pre></pre>
<p>Create a new rust file in <code>src/items</code> called <code>your_weapon.rs</code>. I'll name the item file for this example <code>sniper.rs</code>.</p>
<p>At the top of the file, add the following imports:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use macroquad::{
    experimental::{
        animation::{AnimatedSprite, Animation},
        collections::storage,
        scene::{self, HandleUntyped},
    },
    prelude::*,
};

use crate::{
    components::{GunlikeAnimation, PhysicsBody, ThrowableItem},
    items::gun::Gun,
    Resources,
};
<span class="boring">}
</span></code></pre></pre>
<p>Next, define some constant values for your new item. The following are the values that I came up with for the sniper rifle, but you should play around with your own values until you find values that you like for your item.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const SNIPER_COLLIDER_WIDTH: f32 = 48.0;
const SNIPER_COLLIDER_HEIGHT: f32 = 32.0;
const SNIPER_RECOIL: f32 = 1400.0;
const SNIPER_BULLETS: i32 = 2;
const SNIPER_BULLET_SPEED: f32 = 1200.0;
<span class="boring">}
</span></code></pre></pre>
<p>Next, create an <code>impl Gun</code> block and add a public function called <code>spawn_your_weapon</code>, for the sniper weapon I'm calling this function <code>spawn_sniper</code>. Then, add code to this function to spawn your new weapon. It should be very similar to the code I have here, but with your weapon's values instead of the sniper values. I copied the following code from <code>src/items/musket.rs</code> and changed the values to suit for my sniper weapon.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Gun {
    pub fn spawn_sniper(pos: Vec2) -&gt; HandleUntyped {
        let mut resources = storage::get_mut::&lt;Resources&gt;();

        let gun_sprite = GunlikeAnimation::new(
            AnimatedSprite::new(
                92,
                32,
                &amp;[
                    Animation {
                        name: &quot;idle&quot;.to_string(),
                        row: 0,
                        frames: 1,
                        fps: 1,
                    },
                    Animation {
                        name: &quot;shoot&quot;.to_string(),
                        row: 1,
                        frames: 3,
                        fps: 15,
                    },
                ],
                false,
            ),
            resources.items_textures[&quot;sniper/gun&quot;], // Change this to `your_weapon/gun`
            SNIPER_COLLIDER_WIDTH,
        );

        let gun_fx_sprite = GunlikeAnimation::new(
            AnimatedSprite::new(
                92,
                32,
                &amp;[Animation {
                    name: &quot;shoot&quot;.to_string(),
                    row: 2,
                    frames: 3,
                    fps: 15,
                }],
                false,
            ),
            resources.items_textures[&quot;sniper/gun&quot;], // Change this to `your_weapon/gun`
            SNIPER_COLLIDER_WIDTH,
        );

        scene::add_node(Gun {
            gun_sprite,
            gun_fx_sprite,
            gun_fx: false,
            body: PhysicsBody::new(
                &amp;mut resources.collision_world,
                pos,
                0.0,
                vec2(SNIPER_COLLIDER_WIDTH, SNIPER_COLLIDER_HEIGHT),
            ),
            throwable: ThrowableItem::default(),
            // Use your weapon's constants here
            bullets: SNIPER_BULLETS,
            max_bullets: SNIPER_BULLETS,
            bullet_speed: SNIPER_BULLET_SPEED,
            collider_width: SNIPER_COLLIDER_WIDTH,
            collider_height: SNIPER_COLLIDER_HEIGHT,
            recoil: SNIPER_RECOIL,
        })
        .untyped()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#items-array" id="items-array">Items Array</a></h3>
<p>Open <code>src/items.rs</code> and add find the <code>ITEMS</code> array. Add an entry to this array for your weapon using your new spawn function. I copied the <code>Item</code> entry for the musket weapon and changed the <code>tiled_name</code> and <code>constructor</code> fields to <code>sniper</code> and <code>gun::Gun::spawn_sniper</code> respectively. The <code>tiled_name</code> field is used identifying the item when designing levels. The <code>constructor</code> is the function to spawn the item into the game. We programmed this spawn function the previous <a href="simple_gun_weapon.html#item-file">Item File</a> section. The following is the entry for the sniper weapon:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Item {
    tiled_name: &quot;sniper&quot;,
    constructor: gun::Gun::spawn_sniper,
    tiled_offset: (-35., -25.),
    textures: &amp;[(&quot;gun&quot;, &quot;assets/Whale/Gun(92x32).png&quot;)], // Temporarily using the existing gun texture
    sounds: &amp;[],
    fxses: &amp;[],
    network_ready: true,
},
<span class="boring">}
</span></code></pre></pre>
<p>If you like, you can skip to the testing section to test your new weapon, but if you haven't added a new texture or modified an existing texture, you will not be able to visually recognize your item before picking it up. For this reason, I recommend you continue to the <a href="simple_gun_weapon.html#texture">Texture</a> section next.</p>
<h2><a class="header" href="#texture" id="texture">Texture</a></h2>
<p>It is important to make sure that your weapon is able to be visually distinguished between the other weapons in the game. When I added the sniper rifle to the <code>ITEMS</code> array, I copied all of the data from existing musket weapon, changing only the <code>tiled_name</code> and <code>constructor</code>. To give my sniper weapon a new texture, I will also need to change the <code>gun</code> texture in the <code>textures</code> field. Currently, the <code>gun</code> texture is set to <code>assets/Whale/Gun(92x32).png</code>. I'll open this file with my pixel editor of choice, <a href="https://www.aseprite.org/">Aseprite</a> (<a href="https://www.gimp.org/">GIMP</a> would also work fine).</p>
<p><img src="assets/open_gun_texture.png" alt="open_gun_texture" /></p>
<p>I don't consider myself an artist so I'm just going to modify the hue of the golden part of the gun texture to a reddish color. First I'll select a color range and adjust the threshold to select only the golden part of the gun texture.</p>
<p><img src="assets/select_gun_colors.png" alt="select_gun_colors" /></p>
<p>Then I'll adjust the hue of the selected colors to turn all of the gold color red.</p>
<p><img src="assets/adjust_gun_hue.png" alt="adjust_gun_hue" /></p>
<p>This texture is now distinguishable from the other gun textures in the game. I'll save this new texture into the project's <code>assets/Whale</code> directory as <code>Sniper(92x32).png</code>.</p>
<p>This, of course, is just one way of distinguishing the texture from the other textures in the game. Feel free to copy and modify textures using your own methods, or if you feel inclined, make your own unique texture for your weapon!</p>
<p>Now all I have to do to put my new texture in the game is to change value of the gun texture for the sniper entry in the <code>ITEMS</code> array in <code>src/items.rs</code>. Here is the modified sniper entry using the new texture:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Item {
    tiled_name: &quot;sniper&quot;,
    constructor: gun::Gun::spawn_sniper,
    tiled_offset: (-35., -25.),
    textures: &amp;[(&quot;gun&quot;, &quot;assets/Whale/Sniper(92x32).png&quot;)],
    sounds: &amp;[],
    fxses: &amp;[],
    network_ready: true,
},
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#testing" id="testing">Testing</a></h2>
<p>The last thing we need to do is put our new weapon in the game and test it! Fish Fight's levels are defined in json files in the <code>assets/levels</code> directory. For testing items, there is a test level in the game defined in a file called <code>test_level.json</code>. Open this file.</p>
<p>In this file you will see a long list of item entries containing data about items that are placed in the level. The easiest way to add your new weapon to this level is to replace the <code>name</code> field of one of other items currently in the level with the name of your new weapon (referred to as <code>your_weapon</code> throughout this chapter). Here is the entry for my sniper weapon.</p>
<pre><code class="language-json">...
{
    &quot;draworder&quot;:&quot;topdown&quot;,
    &quot;id&quot;:5,
    &quot;name&quot;:&quot;items&quot;,
    &quot;objects&quot;:[
        ...
        {
            &quot;height&quot;:0,
            &quot;id&quot;:147,
            &quot;name&quot;:&quot;sniper&quot;,
            &quot;point&quot;:true,
            &quot;rotation&quot;:0,
            &quot;type&quot;:&quot;&quot;,
            &quot;visible&quot;:true,
            &quot;width&quot;:0,
            &quot;x&quot;:400,
            &quot;y&quot;:690
        },
        ...
    ],
    ...
}
</code></pre>
<p>If you followed all of these steps correctly, your new weapon should be in the game. Run the game using <code>cargo run</code>, then select the test level. You should see your gun in the level and be able to try it out.</p>
<p><img src="assets/sniper_weapon_test.gif" alt="sniper_weapon_test" /></p>
<p>Now all you need to do is modify the values in <code>src/items/your_weapon.rs</code> until the weapon feels right to you! Then you are ready to make a pull request.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
