window.SIDEBAR_ITEMS = {"fn":[["available_parallelism","Gets the logical CPU core count available to the current process."],["tick_global_task_pools_on_main_thread","A function used by `bevy_core` to tick the global tasks pools on the main thread. This will run a maximum of 100 local tasks per executor per call to this function."]],"mod":[["prelude",""]],"struct":[["AsyncComputeTaskPool","A newtype for a task pool for CPU-intensive work that may span across multiple frames"],["ComputeTaskPool","A newtype for a task pool for CPU-intensive work that must be completed to deliver the next frame"],["IoTaskPool","A newtype for a task pool for IO-intensive work (i.e. tasks that spend very little time in a “woken” state)"],["Scope","A `TaskPool` scope for running one or more non-`'static` futures."],["Task","Wraps `async_executor::Task`, a spawned future."],["TaskPool","A thread pool for executing tasks. Tasks are futures that are being automatically driven by the pool on threads owned by the pool."],["TaskPoolBuilder","Used to create a [`TaskPool`]"],["ThreadExecutor","An executor that can only be ticked on the thread it was instantiated on. But can spawn `Send` tasks from other threads."],["ThreadExecutorTicker","Used to tick the [`ThreadExecutor`]. The executor does not make progress unless it is manually ticked on the thread it was created on."]],"trait":[["ParallelIterator","[`ParallelIterator`] closely emulates the `std::iter::Iterator` interface. However, it uses `bevy_task` to compute batches in parallel."],["ParallelSlice","Provides functions for mapping read-only slices across a provided [`TaskPool`]."],["ParallelSliceMut","Provides functions for mapping mutable slices across a provided [`TaskPool`]."]]};